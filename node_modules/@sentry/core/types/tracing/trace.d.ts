import type { Instrumenter, Primitive, Scope, Span, SpanTimeInput, TransactionContext, TransactionMetadata } from '@sentry/types';
import type { SpanAttributes } from '@sentry/types';
import type { SpanOrigin } from '@sentry/types';
import type { TransactionSource } from '@sentry/types';
import { tracingContextFromHeaders } from '@sentry/utils';
interface StartSpanOptions extends TransactionContext {
    /** A manually specified start time for the created `Span` object. */
    startTime?: SpanTimeInput;
    /** If defined, start this span off this scope instead off the current scope. */
    scope?: Scope;
    /** The name of the span. */
    name: string;
    /** An op for the span. This is a categorization for spans. */
    op?: string;
    /** The origin of the span - if it comes from auto instrumenation or manual instrumentation. */
    origin?: SpanOrigin;
    /** Attributes for the span. */
    attributes?: SpanAttributes;
    /**
     * @deprecated Manually set the end timestamp instead.
     */
    trimEnd?: boolean;
    /**
     * @deprecated This cannot be set manually anymore.
     */
    parentSampled?: boolean;
    /**
     * @deprecated Use attributes or set data on scopes instead.
     */
    metadata?: Partial<TransactionMetadata>;
    /**
     * The name thingy.
     * @deprecated Use `name` instead.
     */
    description?: string;
    /**
     * @deprecated Use `span.setStatus()` instead.
     */
    status?: string;
    /**
     * @deprecated Use `scope` instead.
     */
    parentSpanId?: string;
    /**
     * @deprecated You cannot manually set the span to sampled anymore.
     */
    sampled?: boolean;
    /**
     * @deprecated You cannot manually set the spanId anymore.
     */
    spanId?: string;
    /**
     * @deprecated You cannot manually set the traceId anymore.
     */
    traceId?: string;
    /**
     * @deprecated Use an attribute instead.
     */
    source?: TransactionSource;
    /**
     * @deprecated Use attributes or set tags on the scope instead.
     */
    tags?: {
        [key: string]: Primitive;
    };
    /**
     * @deprecated Use attributes instead.
     */
    data?: {
        [key: string]: any;
    };
    /**
     * @deprecated Use `startTime` instead.
     */
    startTimestamp?: number;
    /**
     * @deprecated Use `span.end()` instead.
     */
    endTimestamp?: number;
    /**
     * @deprecated You cannot set the instrumenter manually anymore.
     */
    instrumenter?: Instrumenter;
}
/**
 * Wraps a function with a transaction/span and finishes the span after the function is done.
 *
 * Note that if you have not enabled tracing extensions via `addTracingExtensions`
 * or you didn't set `tracesSampleRate`, this function will not generate spans
 * and the `span` returned from the callback will be undefined.
 *
 * This function is meant to be used internally and may break at any time. Use at your own risk.
 *
 * @internal
 * @private
 *
 * @deprecated Use `startSpan` instead.
 */
export declare function trace<T>(context: TransactionContext, callback: (span?: Span) => T, onError?: (error: unknown, span?: Span) => void, afterFinish?: () => void): T;
/**
 * Wraps a function with a transaction/span and finishes the span after the function is done.
 * The created span is the active span and will be used as parent by other spans created inside the function
 * and can be accessed via `Sentry.getSpan()`, as long as the function is executed while the scope is active.
 *
 * If you want to create a span that is not set as active, use {@link startInactiveSpan}.
 *
 * Note that if you have not enabled tracing extensions via `addTracingExtensions`
 * or you didn't set `tracesSampleRate`, this function will not generate spans
 * and the `span` returned from the callback will be undefined.
 */
export declare function startSpan<T>(context: StartSpanOptions, callback: (span: Span | undefined) => T): T;
/**
 * @deprecated Use {@link startSpan} instead.
 */
export declare const startActiveSpan: typeof startSpan;
/**
 * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span
 * after the function is done automatically. You'll have to call `span.end()` manually.
 *
 * The created span is the active span and will be used as parent by other spans created inside the function
 * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.
 *
 * Note that if you have not enabled tracing extensions via `addTracingExtensions`
 * or you didn't set `tracesSampleRate`, this function will not generate spans
 * and the `span` returned from the callback will be undefined.
 */
export declare function startSpanManual<T>(context: StartSpanOptions, callback: (span: Span | undefined, finish: () => void) => T): T;
/**
 * Creates a span. This span is not set as active, so will not get automatic instrumentation spans
 * as children or be able to be accessed via `Sentry.getSpan()`.
 *
 * If you want to create a span that is set as active, use {@link startSpan}.
 *
 * Note that if you have not enabled tracing extensions via `addTracingExtensions`
 * or you didn't set `tracesSampleRate` or `tracesSampler`, this function will not generate spans
 * and the `span` returned from the callback will be undefined.
 */
export declare function startInactiveSpan(context: StartSpanOptions): Span | undefined;
/**
 * Returns the currently active span.
 */
export declare function getActiveSpan(): Span | undefined;
export declare function continueTrace({ sentryTrace, baggage, }: {
    sentryTrace: Parameters<typeof tracingContextFromHeaders>[0];
    baggage: Parameters<typeof tracingContextFromHeaders>[1];
}): Partial<TransactionContext>;
export declare function continueTrace<V>({ sentryTrace, baggage, }: {
    sentryTrace: Parameters<typeof tracingContextFromHeaders>[0];
    baggage: Parameters<typeof tracingContextFromHeaders>[1];
}, callback: (transactionContext: Partial<TransactionContext>) => V): V;
export {};
//# sourceMappingURL=trace.d.ts.map